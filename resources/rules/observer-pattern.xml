<pattern name="Observer Pattern with Concrete subject" base-pattern="Observer" >
	<entity id="e1" name="Observer" type="Abstraction" />
	<entity id="e2" name="Concrete Observer" type="Class" /> 						<!-- imagine a deep inheritance heirachy, at this point the only ones that actually matter are the real observers not the classes that describe them -->
	<entity id="e3" name="Subject" type="Class" />									<!-- the subject is the entity that 'calls' the observers, this operation can only be performed by a concrete instance" -->

	<!-- does this look like observer? -->
	<!-- consequently, the rule filters describe what observer patterns should "look" like -->
	<rule rule-type="Dependency"  source="e2" value="Extend" target="e1" /> 	<!-- specifies the concrete observer has to extend or implement the observer interface -->
	<rule rule-type="Dependency"  source="e3" value="Use" target="e1" /> 			<!-- specifies the concrete subject has observer. This can be in a list as in List<IObserver> observers. -->
	<rule rule-type="Cardinality" source="e2" value="Plural" optional="true" />		<!-- specifies that there should be multiple observers. It is optional because it neither validates nor invalidates an instance of observer pattern -->
	<rule rule-type="Dependency" source="e3" value="Call" target="e1" />			<!-- specifies that the subject should call a method in the observer interface like the notify() method. -->

	<!-- yes it does look like observer, is it actually observer? -->
	<!-- Thus, the code-analysis determines if an instance that looks like observer pattern is actually observer pattern. -->
	<rule rule-type="AST_Analyze" source="e3" value="Aggregates" target="e1" />		<!-- we already know subject uses observer, this validates that this usage is in the form of a collection of observers-->
	<rule rule-type="AST_Analyze" source="e3" value="Loops" target="e1" />			<!-- we already know that there is a method in the subject that calls the observer; this validates that the call is made inside a loop of observers -->
	
	<resolver resolver-type="SEPARATE" source="e1" />									<!-- separate multiple instances by the observer interface, repeat the process above -->
</pattern>


<!--

Test cases
==========
how do you ensure that same classes don't fall into concrete observer and observer interface
how do you ensure that same classes don't fall into concrete observer and subject
if there are multiple void methods in the observer interface, how do you select the notify() method?
if there are multiple forLoops in the subject to the observer, how do you select the notify() method?
if there are intermediary inheritance heirachies between the observer interface and concrete observers, where do they go?

-->
