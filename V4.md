Notes
-----

* Testament to how fast software ages, didn't even finish v3 before v4 came up
* Moving away from structured (formal) type to an REPL style specification for more flexibility


* While defining conditions for fill, filter etc on buckets, the second entity is regarded as the pivot entity.

What happens when I evaluate
============================

b <= conc extend abs

1. we ask the dsm browser to give us all the tuple of all classes participating in the extend relationship
    it's result it's put in the aux and pivot entities
    it's result is cached, multiple requests return same elements
    it's results are pocketed

2. we create entities matching the conc and abs in the dsm result
    then we put aux and pivot in the conc and abs operands of dsm result respectively

3. we create conc and abs in b if they dont exist
    we add the classes from the dsm result to the entities in b

4. if pivot is specified, we set the group pockets by pivot

There are four different places where things can go wrong
1. dsm.get('extend') is a separate function that should return the same thing all the time
2. r = apply(r, conc, abs) should apply result to the entities
2. b.apply(result, conc, abs) should do only applying

b = 'IObserver' type_name observerI - doesn't work as expected.
If it worked, observerI should be emtpy which would cause all other entities to be emptied
1. type_name is not working as expected
2. type_name works as expected but apply not working as expected

3. how do we isolate type_name?, change to type_name('IObserver', b.observerI);
     - returns a bucketResult containing all classes in observerI that has this type name.
     - on the bright side, we can now print the result of type_name using print or pockets

     method_name(b.get(observerI), list("notify", "update"));
     min_pocket_size(b.get(conObserver), 2);                    // returns a result containing on conObserver entity with classes more than 2 pockets
     dependency(specialize);                                    // returns a result containing the tuple aux and pivot for specialize
     dependency(array(specialize, typed));                      // same as above except for array

     apply(dependency(specialize), b.get(e1), b.get(e2));       // returns a result where e1 and e2 has been added, where dep result has been trimmed to match e1 and e2 and
     // thinking about passing in the entity names only not the reference. better still, breaking down apply to something meaningful
     [contd.] essentially trimToMatch + resolve
     print(b.get(observerI))                                    // prints this entity, require every model to implement good to string
     prettyPrint(b.get(observerI))                              // pretty prints entity or any object that implements prettyString();
b.fill( apply( dependency(specialize), b.get(e1), b.get(e2)));
b.filter(...)
b.assign(...)
b.demote(...)
b.promote(...)



PRASO Grammar:

[x] denotes zero or one occurrences of x
{x} denotes zero or more occurrences of x
(x|y) means one of either x or y


Identifier:
    IDENTIFIER

PivotIdentifier:
	*Identifier

QualifiedIdentifier:
    Identifier { . Identifier }
    
QualifiedIdentifierList:
    [ QualifiedIdentifier { , QualifiedIdentifier } ]
    
IdentifierExpression:
    (QualifiedIdentifier | PivotIdentifier | QualifiedIdentifierList)
    
TypeDeclaration:
    TypeKeyword Identifier Literal
       
Literal:
    ' IDENTIFIER '
    
LiteralList:
    [ Literal { , Literal } ]
    
TypeKeyword:
    entity
    bucket

Statement:
    TypeDeclaration
    BucketStatement
    FunctionStatement
    
BucketStatement:
    Identifier BucketOperator BucketCondition
    
BucketOperator:
    =
    =>
    <=
    ++
    --
    
BucketCondition:
    (DependencyCondition | FunctionalCondition)
    
DependencyCondition:
    IdentifierExpression DependencyOperatorExpression IdentifierExpression
    
DependencyOperatorExpression:
    (DependencyOperator | DependencyOperatorList)
    
DependencyOperatorList:
    [ DependencyOperator { , DependencyOperator ]   
     
DependencyOperator:
    use,
    type,
    call,
    implement,
    extend,
    specialize,
    import
    create
    throw

FunctionalCondition:
    FunctionStatement
    
FunctionStatement:
    Literal ( ArgumentList )

ArgumentList:
    Argument { , Argument }

Argument:
    (Literal | IdentifierExpression)
